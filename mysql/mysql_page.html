<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MySQL高级语法 - REPLACE INTO与INSERT ON DUPLICATE KEY UPDATE</title>
    <style>
        /* 基础样式 - 极简主义Apple风格 */
        :root {
            --primary-color: #0066cc; /* Apple蓝 */
            --text-color: #333333;
            --light-gray: #f5f5f7;
            --border-color: #e6e6e6;
        }
        
        body {
            font-family: "SF Pro Text", "SF Pro Icons", "Helvetica Neue", Helvetica, Arial, sans-serif;
            color: var(--text-color);
            line-height: 1.6;
            margin: 0;
            padding: 0;
            background-color: white;
        }
        
        /* 页面容器 */
        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 0 20px;
        }
        
        /* 顶部导航 */
        .nav-container {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background-color: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid var(--border-color);
            z-index: 100;
        }
        
        .nav {
            max-width: 800px;
            margin: 0 auto;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .nav-title {
            font-size: 18px;
            font-weight: 500;
        }
        
        .nav-links {
            display: flex;
            gap: 20px;
        }
        
        .nav-link {
            color: var(--primary-color);
            text-decoration: none;
            font-size: 14px;
            transition: opacity 0.2s;
        }
        
        .nav-link:hover {
            opacity: 0.7;
        }
        
        /* 侧边导航（桌面版） */
        .sidebar {
            position: fixed;
            top: 70px;
            left: 20px;
            width: 180px;
            padding: 20px 0;
            display: none; /* 默认隐藏，宽屏显示 */
        }
        
        .sidebar-link {
            display: block;
            padding: 8px 10px;
            margin-bottom: 5px;
            color: var(--text-color);
            text-decoration: none;
            border-radius: 5px;
            font-size: 14px;
            transition: background-color 0.2s;
        }
        
        .sidebar-link:hover {
            background-color: var(--light-gray);
        }
        
        .sidebar-link.active {
            background-color: var(--light-gray);
            color: var(--primary-color);
            font-weight: 500;
        }
        
        /* 内容区域 */
        .content {
            padding-top: 70px;
            padding-bottom: 50px;
        }
        
        /* 引言区 */
        .intro {
            margin-bottom: 40px;
            padding: 30px 0;
            border-bottom: 1px solid var(--border-color);
        }
        
        .intro h1 {
            font-size: 32px;
            font-weight: 600;
            margin-bottom: 20px;
        }
        
        /* 主题区 */
        .section {
            margin-bottom: 40px;
            scroll-margin-top: 80px; /* 滚动到此区域时的顶部边距 */
        }
        
        h2 {
            font-size: 24px;
            font-weight: 600;
            margin-top: 40px;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border-color);
        }
        
        h3 {
            font-size: 18px;
            font-weight: 500;
            margin-top: 30px;
            margin-bottom: 15px;
            color: var(--primary-color);
        }
        
        p {
            margin-bottom: 20px;
        }
        
        /* 代码块 */
        pre {
            background-color: var(--light-gray);
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            font-family: "SF Mono", "Menlo", "Monaco", "Courier New", monospace;
            font-size: 14px;
            line-height: 1.5;
        }
        
        code {
            font-family: "SF Mono", "Menlo", "Monaco", "Courier New", monospace;
            font-size: 14px;
            background-color: var(--light-gray);
            padding: 2px 4px;
            border-radius: 3px;
        }
        
        /* 列表样式 */
        ul, ol {
            padding-left: 20px;
            margin-bottom: 20px;
        }
        
        li {
            margin-bottom: 8px;
        }
        
        /* 表格样式 */
        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
        }
        
        th, td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid var(--border-color);
        }
        
        th {
            background-color: var(--light-gray);
            font-weight: 500;
        }
        
        /* 页脚 */
        .footer {
            margin-top: 50px;
            padding: 20px 0;
            border-top: 1px solid var(--border-color);
            font-size: 14px;
            color: #666;
        }
        
        /* 进度指示器 */
        .progress-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 3px;
            background: transparent;
            z-index: 200;
        }
        
        .progress-bar {
            height: 3px;
            background: var(--primary-color);
            width: 0%;
        }
        
        /* 响应式设计 */
        @media (min-width: 1200px) {
            .container {
                margin-left: 220px;
            }
            
            .sidebar {
                display: block;
            }
        }
        
        @media (max-width: 768px) {
            .nav-links {
                display: none;
            }
            
            .mobile-nav {
                display: block;
                margin-top: 20px;
                padding-bottom: 10px;
                border-bottom: 1px solid var(--border-color);
            }
            
            .mobile-nav-link {
                display: inline-block;
                margin-right: 15px;
                margin-bottom: 10px;
                font-size: 14px;
                color: var(--primary-color);
                text-decoration: none;
            }
        }
    </style>
</head>
<body>
    <!-- 进度指示器 -->
    <div class="progress-container">
        <div class="progress-bar" id="progressBar"></div>
    </div>
    
    <!-- 顶部导航 -->
    <div class="nav-container">
        <div class="nav">
            <div class="nav-title">MySQL高级语法</div>
            <div class="nav-links">
                <a href="#replace-into" class="nav-link">REPLACE INTO</a>
                <a href="#insert-on-duplicate" class="nav-link">INSERT ON DUPLICATE KEY UPDATE</a>
                <a href="#comparison" class="nav-link">对比分析</a>
                <a href="#performance" class="nav-link">性能考虑</a>
            </div>
        </div>
    </div>
    
    <!-- 侧边导航 -->
    <div class="sidebar">
        <a href="#replace-into" class="sidebar-link">REPLACE INTO</a>
        <a href="#replace-intro" class="sidebar-link">简介</a>
        <a href="#replace-syntax" class="sidebar-link">基本语法</a>
        <a href="#replace-mechanism" class="sidebar-link">工作原理</a>
        <a href="#replace-example" class="sidebar-link">使用示例</a>
        <a href="#replace-notes" class="sidebar-link">注意事项</a>
        
        <a href="#insert-on-duplicate" class="sidebar-link">INSERT ON DUPLICATE KEY UPDATE</a>
        <a href="#insert-process" class="sidebar-link">执行过程</a>
        <a href="#insert-syntax" class="sidebar-link">基本语法</a>
        <a href="#insert-mechanism" class="sidebar-link">详细工作机制</a>
        <a href="#insert-examples" class="sidebar-link">高级用法示例</a>
        <a href="#insert-details" class="sidebar-link">内部实现细节</a>
        
        <a href="#comparison" class="sidebar-link">两种方法的对比</a>
        <a href="#use-cases" class="sidebar-link">适用场景</a>
        <a href="#performance" class="sidebar-link">性能考虑</a>
    </div>
    
    <!-- 移动端导航 -->
    <div class="container">
        <div class="mobile-nav">
            <a href="#replace-into" class="mobile-nav-link">REPLACE INTO</a>
            <a href="#insert-on-duplicate" class="mobile-nav-link">INSERT ON DUPLICATE KEY UPDATE</a>
            <a href="#comparison" class="mobile-nav-link">对比分析</a>
            <a href="#performance" class="mobile-nav-link">性能考虑</a>
        </div>
    </div>
    
    <!-- 内容区域 -->
    <div class="container">
        <div class="content">
            <!-- 引言区 -->
            <div class="intro">
                <h1>MySQL中REPLACE INTO与INSERT ON DUPLICATE KEY UPDATE的原理</h1>
                <p>MySQL提供了两种处理数据冲突的高级语法：REPLACE INTO和INSERT ON DUPLICATE KEY UPDATE。本文详细介绍这两种语法的工作原理、使用场景和性能对比。</p>
            </div>
            
            <!-- REPLACE INTO 部分 -->
            <div id="replace-into" class="section">
                <h2>REPLACE INTO</h2>
                
                <div id="replace-intro" class="section">
                    <h3>简介</h3>
                    <p><code>REPLACE INTO</code>是MySQL特有的扩展SQL语句，用于在插入数据时自动处理记录冲突的情况。它可以在一个语句中完成"如果存在则替换，不存在则插入"的逻辑。</p>
                </div>
                
                <div id="replace-syntax" class="section">
                    <h3>基本语法</h3>
                    <pre>REPLACE INTO 表名 (列1, 列2, ...) VALUES (值1, 值2, ...);
-- 或
REPLACE INTO 表名 SET 列1=值1, 列2=值2, ...;
-- 或
REPLACE INTO 表名 SELECT ...;</pre>
                </div>
                
                <div id="replace-mechanism" class="section">
                    <h3>工作原理</h3>
                    <ol>
                        <li>MySQL尝试插入一行新记录</li>
                        <li>如果该行数据不违反主键或唯一索引约束，则正常插入</li>
                        <li>如果违反主键或唯一索引约束（即有重复值）：
                            <ul>
                                <li>先删除已存在的冲突记录</li>
                                <li>然后插入新记录</li>
                            </ul>
                        </li>
                    </ol>
                    
                    <p>本质上等同于执行：</p>
                    <pre>DELETE FROM 表名 WHERE 主键或唯一键存在冲突;
INSERT INTO 表名 (列1, 列2, ...) VALUES (值1, 值2, ...);</pre>
                </div>
                
                <div id="replace-example" class="section">
                    <h3>使用示例</h3>
                    <pre>-- 创建示例表
CREATE TABLE users (
  id INT PRIMARY KEY,
  username VARCHAR(50) UNIQUE,
  email VARCHAR(100)
);

-- 插入记录
REPLACE INTO users (id, username, email) VALUES (1, 'user1', 'user1@example.com');

-- 替换已存在的记录
REPLACE INTO users (id, username, email) VALUES (1, 'user1', 'new_email@example.com');</pre>
                </div>
                
                <div id="replace-notes" class="section">
                    <h3>注意事项</h3>
                    <ul>
                        <li>表必须有主键或唯一索引才能触发替换功能</li>
                        <li>会完全删除旧记录并创建新记录，而非UPDATE操作</li>
                        <li>未在REPLACE语句中明确指定的列将被设置为默认值</li>
                        <li>会重置自增ID（如果不是主键的话）</li>
                        <li>返回值为受影响的行数：插入为1，替换为2（1行删除+1行插入）</li>
                        <li>会触发DELETE和INSERT触发器，但不会触发UPDATE触发器</li>
                    </ul>
                </div>
            </div>
            
            <!-- INSERT ON DUPLICATE KEY UPDATE 部分 -->
            <div id="insert-on-duplicate" class="section">
                <h2>INSERT ON DUPLICATE KEY UPDATE</h2>
                
                <div id="insert-process" class="section">
                    <h3>执行过程</h3>
                    <ol>
                        <li>MySQL尝试执行普通的INSERT操作</li>
                        <li>如果插入的数据不违反任何唯一约束(主键或唯一索引)，则正常插入成功</li>
                        <li>如果发生唯一约束冲突：
                            <ul>
                                <li>不删除现有记录</li>
                                <li>将指定的UPDATE子句应用到已存在的记录上</li>
                                <li>只更新显式指定的列，其他列保持不变</li>
                            </ul>
                        </li>
                    </ol>
                </div>
                
                <div id="insert-syntax" class="section">
                    <h3>基本语法</h3>
                    <pre>INSERT INTO 表名 (列1, 列2, ...) 
VALUES (值1, 值2, ...)
ON DUPLICATE KEY UPDATE 列1=新值1, 列2=新值2, ...;</pre>
                </div>
                
                <div id="insert-mechanism" class="section">
                    <h3>详细工作机制</h3>
                    <ul>
                        <li>在UPDATE部分可以引用VALUES()函数获取尝试插入的值
                            <ul>
                                <li>VALUES(列名)是一个特殊函数，用于引用当前INSERT语句中尝试插入的新值</li>
                                <li>它允许你在UPDATE子句中使用这些原始插入值，而不需要重复指定</li>
                                <li>例如：<code>visit_count = visit_count + VALUES(visit_count)</code> 表示将当前值加上尝试插入的新值</li>
                                <li>非常适合计数器更新、累加操作或需要参考原始插入值的场景</li>
                            </ul>
                        </li>
                        <li>可以有选择地更新部分列，不必更新所有冲突列</li>
                        <li>可以使用表达式或计算结果作为更新值</li>
                        <li>返回值：
                            <ul>
                                <li>插入新行：影响行数为1</li>
                                <li>更新已有行：影响行数为2</li>
                                <li>没有变化：影响行数为0</li>
                            </ul>
                        </li>
                    </ul>
                </div>
                
                <div id="insert-examples" class="section">
                    <h3>高级用法示例</h3>
                    <pre>-- 使用VALUES()引用插入值
INSERT INTO visits (user_id, page, visit_count) 
VALUES (1, 'home', 1)
ON DUPLICATE KEY UPDATE visit_count = visit_count + VALUES(visit_count);

-- 条件更新
INSERT INTO products (id, name, stock) 
VALUES (101, 'Smartphone', 5)
ON DUPLICATE KEY UPDATE 
  stock = stock + VALUES(stock),
  name = IF(LENGTH(VALUES(name)) > LENGTH(name), VALUES(name), name);</pre>
                </div>
                
                <div id="insert-details" class="section">
                    <h3>内部实现细节</h3>
                    <ol>
                        <li>获取写锁(行锁或表锁，取决于事务隔离级别)</li>
                        <li>检查唯一键冲突</li>
                        <li>如果存在冲突，将INSERT转换为UPDATE操作</li>
                        <li>在同一事务中完成整个操作，保证原子性</li>
                        <li>如果使用InnoDB，会复用已获取的锁</li>
                    </ol>
                </div>
            </div>
            
            <!-- 两种方法的对比 -->
            <div id="comparison" class="section">
                <h2>两种方法的对比</h2>
                
                <h3>REPLACE INTO vs INSERT ON DUPLICATE KEY UPDATE</h3>
                <table>
                    <tr>
                        <th>特性</th>
                        <th>INSERT ON DUPLICATE KEY UPDATE</th>
                        <th>REPLACE INTO</th>
                    </tr>
                    <tr>
                        <td>数据保留</td>
                        <td>保留未明确更新的列值</td>
                        <td>删除旧记录，所有未指定列重置为默认值</td>
                    </tr>
                    <tr>
                        <td>执行操作</td>
                        <td>一次UPDATE操作</td>
                        <td>一次DELETE + 一次INSERT操作</td>
                    </tr>
                    <tr>
                        <td>触发器</td>
                        <td>触发INSERT或UPDATE触发器</td>
                        <td>触发DELETE和INSERT触发器</td>
                    </tr>
                    <tr>
                        <td>灵活性</td>
                        <td>可以有选择地、有条件地更新</td>
                        <td>简单但不够灵活</td>
                    </tr>
                    <tr>
                        <td>自增ID</td>
                        <td>保持不变</td>
                        <td>可能会变化(如果不是主键)</td>
                    </tr>
                    <tr>
                        <td>性能</td>
                        <td>通常更高效(特别是有多个索引的表)</td>
                        <td>需要额外的删除操作</td>
                    </tr>
                </table>
                
                <ul>
                    <li><code>REPLACE INTO</code>：
                        <ul>
                            <li>完全删除冲突记录再插入</li>
                            <li>会重置未指定列为默认值</li>
                            <li>操作简单但可能丢失数据</li>
                        </ul>
                    </li>
                    <li><code>INSERT ON DUPLICATE KEY UPDATE</code>：
                        <ul>
                            <li>只更新指定的列，保留其他列原有值</li>
                            <li>更灵活，可以有条件地更新</li>
                            <li>不会触发DELETE触发器</li>
                        </ul>
                    </li>
                </ul>
                
                <pre>-- 对比示例
INSERT INTO users (id, username, email) 
VALUES (1, 'user1', 'new_email@example.com')
ON DUPLICATE KEY UPDATE email='new_email@example.com';</pre>
                
                <div id="use-cases" class="section">
                    <h3>适用场景</h3>
                    <ul>
                        <li><code>REPLACE INTO</code>：
                            <ul>
                                <li>需要完全替换记录的场景</li>
                                <li>简单操作，不关心旧数据</li>
                                <li>数据导入或批量处理</li>
                            </ul>
                        </li>
                        <li><code>INSERT ON DUPLICATE KEY UPDATE</code>：
                            <ul>
                                <li>计数器更新</li>
                                <li>需要保留部分历史数据的更新</li>
                                <li>有条件的数据合并</li>
                                <li>数据汇总或统计更新</li>
                            </ul>
                        </li>
                    </ul>
                </div>
            </div>
            
            <!-- 性能考虑 -->
            <div id="performance" class="section">
                <h2>性能考虑</h2>
                <ul>
                    <li>对于频繁写操作的表，<code>REPLACE INTO</code>可能会导致更多的I/O操作和索引维护开销，因为它执行了删除和插入两个操作</li>
                    <li><code>INSERT ON DUPLICATE KEY UPDATE</code>通常更高效，特别是对于有多个索引的表</li>
                    <li>在高并发环境中，<code>INSERT ON DUPLICATE KEY UPDATE</code>可能有更好的锁行为</li>
                </ul>
            </div>
            
            <!-- 页脚 -->
            <div class="footer">
                <p>MySQL高级语法 - REPLACE INTO与INSERT ON DUPLICATE KEY UPDATE的原理</p>
            </div>
        </div>
    </div>
    
    <script>
        // 滚动进度条
        window.onscroll = function() {
            var winScroll = document.body.scrollTop || document.documentElement.scrollTop;
            var height = document.documentElement.scrollHeight - document.documentElement.clientHeight;
            var scrolled = (winScroll / height) * 100;
            document.getElementById("progressBar").style.width = scrolled + "%";
            
            // 更新活动导航项
            updateActiveNavItem();
        };
        
        // 平滑滚动
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                
                const targetId = this.getAttribute('href');
                const targetElement = document.querySelector(targetId);
                
                if (targetElement) {
                    window.scrollTo({
                        top: targetElement.offsetTop - 70,
                        behavior: 'smooth'
                    });
                    
                    // 更新URL，但不滚动
                    history.pushState(null, null, targetId);
                }
            });
        });
        
        // 更新活动导航项
        function updateActiveNavItem() {
            const sections = document.querySelectorAll('.section');
            const navLinks = document.querySelectorAll('.sidebar-link');
            
            let currentSection = '';
            
            sections.forEach(section => {
                const sectionTop = section.offsetTop - 100;
                const sectionBottom = sectionTop + section.offsetHeight;
                
                if (window.scrollY >= sectionTop && window.scrollY < sectionBottom) {
                    currentSection = '#' + section.getAttribute('id');
                }
            });
            
            navLinks.forEach(link => {
                link.classList.remove('active');
                if (link.getAttribute('href') === currentSection) {
                    link.classList.add('active');
                }
            });
        }
        
        // 初始化
        document.addEventListener('DOMContentLoaded', function() {
            updateActiveNavItem();
        });
    </script>
</body>
</html> 